<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_turn = 0;
current_faction = 0;

next_turn = false;
turn_phase = 0;

move_phase = 0;
move_phase_count = 0;
move_phase_timer = 0;
move_phase_pause = 0;

collision_hex_list = ds_list_create();
collision_i_list = ds_list_create();
collision_j_list = ds_list_create();

skirmish_hex_list = ds_list_create();
skirmish_i_list = ds_list_create();
skirmish_j_list = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_game_destroy_objects();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Prepare turn calculation

if ( !next_turn ) exit;

var i, j, k, a_list, i_hex, j_hex, hex, index, collision, skirmish, path_inst, path_list, neighbour_i_list, neighbour_j_list, neighbour_list;

switch( turn_phase ) {
    case 0: {
        //Create the "new turn" notification box
        scr_window_create( wnd_next_turn, obj_window_layer.id,   noone, noone, noone, noone );
        
        //Destroy all the post markers
        with( obj_path_post ) instance_destroy();
        
         //Prepare for unit procession
        move_phase = 0;
        move_phase_timer = 0;
        move_phase_retreat = false;
        
        with( obj_army ) can_attack = true;
        
        turn_phase++;
        break;
    }
    
    case 1: {
        
        ds_list_clear( collision_hex_list );
        ds_list_clear( collision_i_list );
        ds_list_clear( collision_j_list );
        
        ds_list_clear( skirmish_hex_list );
        ds_list_clear( skirmish_i_list );
        ds_list_clear( skirmish_j_list );
        
        turn_phase++;
        break;
    }
    
    case 2: { //Animate army movement
        
        move_phase_timer += turn_move_incr;
        
        if ( move_phase_timer &gt;= 1 ) {
            
            move_phase_timer = 1;
            move_phase_pause += turn_pause_incr;
            
            if ( move_phase_pause &gt;= 1 ) {
                
                move_phase_timer = 0;
                move_phase_pause = 0;
                
                with( obj_army ) if ( path != noone ) {
                    path_ind = min( ds_list_size( path.path_list ) - 1, path_ind + 1 );
                    hex_location = ds_list_find_value( path.path_list, path_ind );                    
                }
                
                move_phase++;
                turn_phase++;
            }
        }
        
        with( obj_army ) if ( path != noone ) path_tween = other.move_phase_timer;
        
        break;
    }
    
    case 3: {
            
        //This is the army collision code
        //For all armies
        with( obj_army ) {
            
            if ( !can_attack ) continue;
            collision = false;
            neighbour_i_list = ds_list_find_value( obj_world.lst_hex_list_adj, hex_location ); //Grab the neighbour list for the hex this army is standing in
            
            //For all armies (including stationary armies this time)
            with( obj_army ) {
                    
                if ( id == other.id ) continue; //Ignore self-comparison
                
                if ( other.hex_location == hex_location ) or ( ds_list_find_index( neighbour_i_list, hex_location ) &gt;= 0 ) {
                    
                    collision = true;
                    with( path ) instance_destroy();
                    
                    if ( !ds_list_find_duplicate( other.id, id, par_game.collision_i_list, par_game.collision_j_list ) ) {
                        ds_list_add( par_game.collision_hex_list, hex_location );
                        ds_list_add( par_game.collision_i_list, other.id );
                        ds_list_add( par_game.collision_j_list, id );
                    }
                }
            }
        }
        
        if ( ds_list_size( collision_hex_list ) &gt; 0 ) turn_phase = 4 else {
            if ( !scr_check_for_remaining_army_paths() ) turn_phase = 5 else turn_phase = 1;
        }
        break;
    }
    
    case 4: {
        
        while( ds_list_size( collision_hex_list ) &gt; 0 ) {
            
            hex = ds_list_find_value( collision_hex_list, 0 );
            i_inst = ds_list_find_value( collision_i_list, 0 ); //The attacking army
            j_inst = ds_list_find_value( collision_j_list, 0 ); //The defending army
            
            ds_list_delete( collision_hex_list, 0 );
            ds_list_delete( collision_i_list, 0 );
            ds_list_delete( collision_j_list, 0 );
            
            with( i_inst ) {
                retreat_hex = scr_find_free_hex_for_army( id );
                can_attack = false;
                path_ind = 0;
            }
            
            with( j_inst ) {
                retreat_hex = scr_find_free_hex_for_army( id );
                can_attack = false;
                path_ind = 0;
            }
            
            //If movement created by this battle exceeds the total moves for this turn, add another move phase and tell the engine to avoid calculating collisions for this final final phase
            if ( !scr_check_for_remaining_army_paths() ) with( obj_army ) can_attack = false;
            
            if ( j_inst.retreat_hex != noone ) scr_create_simple_path_for_army( j_inst, j_inst.hex_location, j_inst.retreat_hex ) else with( j_inst ) instance_destroy();
            
        }
        
        turn_phase = 1;
        break;
    }
    
    case 5: {
        
        with( obj_path ) instance_destroy();
        with ( obj_army ) {
            path_ind = 0;
            path_tween = 0;
        }
        
        scr_window_close( wnd_next_turn );
        turn_phase = 0;
        next_turn = false;
        game_turn++;
        break;
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
                
                /*
                if ( !collision ) {
                    
                    //If there's no direction confronations for this army, check for skirmishes in the AoC
                    skirmish = false;
                    hex = noone;
                    
                    //For all armies (again, not ignoring stationary armies)
                    for( j = 0; j &lt; instance_number( obj_army ); j++ ) {
                        
                        if ( i == j ) continue; //Reject self-intersection
                        if !( j_inst.can_attack ) or !( i_inst.can_attack ) continue; //If one of the armies can't attack, there's no skirmish
                        
                        j_inst = instance_find( obj_army, j );
                        j_list = ds_list_find_value( obj_world.lst_hex_list_adj, j_inst.hex_location ); //Grab the AoC for the other army
                        
                        index = ds_list_find_in_list( i_list, j_list );
                        
                        if ( index &gt;= 0 ) {
                            hex = ds_list_find_value( j_list, index );
                            skirmish = true;
                            if ( !ds_list_find_duplicate( i_inst, j_inst, skirmish_i_list, skirmish_j_list ) ) {
                                ds_list_add( skirmish_hex_list, j_inst.hex_location );
                                ds_list_add( skirmish_i_list, i_inst );
                                ds_list_add( skirmish_j_list, j_inst );
                            }
                        }
                    }
                    
                    if ( skirmish ) {
                        //i_inst.retreat_hex = ds_list_find_value( (i_inst.path).path_list, max( 0, move_phase - 1 ) );
                        //with( i_inst.path ) instance_destroy();
                        //i_inst.path = noone;
                        show_message( "Skirmish at " + string( hex ) + " between " + string( i_inst ) + " and " + string( j_inst ) );
                    }
                }
                */
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*

var faction_inst;

faction_inst = ds_list_find_value( faction_instance_list, current_faction );

draw_set_color( faction_inst.colour );
draw_rectangle( 0, view_hview[0] - 50, 50, view_hview[0], false );

draw_set_halign( fa_center );
draw_set_valign( fa_middle );
draw_set_font( fnt_default );
draw_set_alpha( 0.5 );
draw_set_color( c_black );
draw_text( 27, view_hview[0] - 23, string( current_faction ) );
draw_set_color( c_off_white );
draw_text( 25, view_hview[0] - 25, string( current_faction ) );
draw_set_halign( fa_left );
draw_set_valign( fa_top );

*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
