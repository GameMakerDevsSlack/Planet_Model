<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>par_game</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Client init

//Tell the log what's going on
ds_list_add( log, "~~~ CLIENT mode started" );

event_inherited();

//Create message variables
msg_socket = noone;
msg_type = noone;
msg_ip = noone;
msg_new_socket = noone;

//Start ticketing system
scr_init_ticketing();

//Create an out-going socket. This handles client-to-server communication
socket = network_create_socket( network_socket_tcp );

//Catch socket failure
if ( socket &lt; 0 ) {
    ds_list_add( log, "!!! socket failure !!!" );
    ds_list_add( chat, "A socket could not be opened. Please check your internet connection." );
} else ds_list_add( log, "socket = " + string( socket ) );

//Attempt a connection
network_status = network_connect( socket, multiplayer_server_ip, multiplayer_port );

//Catch connection failure
if ( network_status &lt; 0 ) {
    
    ds_list_add( log, "!!! connection failure !!!" );
    ds_list_add( chat, "The server at " + multiplayer_server_ip + " was not found." );
    instance_destroy();
    
} else {
    
    ds_list_add( log, "ip = " + string( multiplayer_server_ip ) + ":" + string( multiplayer_port ) + ", network status = " + string( network_status ) );
    
    scr_client_request_handshake(); //Send a handshake to the server
    scr_add_timed_ticket( id, tkt_ping, client_req_ping_time ); //Add a ticket to fire off a ping to the server
    scr_add_timed_ticket( id, tkt_ping_timeout, client_check_server_timeout ); //Add a ticket to catch timeouts
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroy event

event_inherited();

scr_destroy_ticketing();
network_destroy( socket );

ds_list_add( log, "!!! client disconnected !!!" );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Step

//Nope out if there's no connection
if ( network_status &lt; 0 ) exit;

scr_process_timed_tickets();

if ( ds_queue_empty( ticket_queue ) ) exit;

var action = ds_queue_dequeue( ticket_queue );

switch( action ) {
    
    case tkt_ping: {
        scr_request_ping();
        scr_add_timed_ticket( id, tkt_ping, client_req_ping_time ); //Add a ticket to fire off another ping to the server
        scr_add_timed_ticket( id, tkt_ping_timeout, client_check_server_timeout ); //Add a ticket to catch a timeout
        break;
    }
    
    case tkt_ping_timeout: {
        scr_client_disconnect();
        ds_list_add( log, "!!! server timeout !!!" );
        ds_list_add( chat, "The server is not responding. The connection has been closed." );
        if ( !instance_exists( wnd_chat ) ) scr_window_create( wnd_chat, obj_window_layer.id,   noone, noone, noone, noone );
        break;
    }
    
    case tkt_request_seed: {
        if ( obj_world.generation_finished ) scr_client_finished_regen() else scr_add_timed_ticket( id, tkt_request_seed, 100 );
        break;
    }
    
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Network Async

var message_type, seed, str;

msg_socket = ds_map_find_value( async_load, "id" );
msg_type = ds_map_find_value(async_load, "type");
msg_ip = ds_map_find_value(async_load, "ip");
msg_new_socket = noone;

if ( msg_type == network_type_connect ) { //erm?
    
    msg_new_socket = ds_map_find_value(async_load, "socket");
    msg_type = "network_type_connect";
    ds_list_add( log, "??? network_type_connect on new " + string( msg_new_socket ) + " (" + string( msg_socket ) + ") ???" );
    
    
    
    
} else if ( msg_type == network_type_disconnect ) { //erm?

    msg_new_socket = ds_map_find_value(async_load, "socket");
    msg_type = "network_type_disconnect";
    ds_list_add( log, "??? network_type_disconnect on " + string( msg_new_socket ) + " (" + string( msg_socket ) + ") ???" );

    
    
    
    
} else if ( msg_type == network_type_data ) {
    
    msg_type = "network_type_data";
    
    msg_buffer = ds_map_find_value( async_load, "buffer" );
    msg_buffer_size = ds_map_find_value( async_load, "size" );
    
    message_type = buffer_read( msg_buffer, buffer_u16 );
    
    ds_list_add( log, string( message_type ) );
    
    switch( message_type ) {
        case server_send_handshake_msg: { //Handshake from server
            
            ds_list_add( log, "server_send_handshake on " + string( msg_socket ) );
            ds_list_add( chat, "Successfully connected to the server." );
            if ( !instance_exists( wnd_chat ) ) scr_window_create( wnd_chat, obj_window_layer.id,   noone, noone, noone, noone );
            
            scr_add_timed_ticket( id, tkt_request_seed, 100 );
            
            scr_remove_all_timed_ticket( id, tkt_ping_timeout );
            break;
        }
        
        case server_rejection_msg: { //Server has not accepted entry to the game
            ds_list_add( log, "server rejected connection" );
            show_message_async( "The server at " + multiplayer_server_ip + " was found but rejected the connection." );
            instance_destroy();
            break;
        }
        
        case send_ping_msg: { //Ping from server
            
            //ds_list_add( log, "ping on " + string( msg_socket ) );
            
            scr_remove_all_timed_ticket( id, tkt_ping_timeout );
            break;
        }
        
        case send_chat_msg: { //Chat message from server
            
            str = buffer_read( msg_buffer, buffer_string );
            
            ds_list_add( chat, str );
            
            scr_remove_all_timed_ticket( id, tkt_ping_timeout );
            break;
        }
        
        case send_list_msg: { //List message from the server
            
            var target = buffer_read( msg_buffer, buffer_u16 );
            var size = buffer_read( msg_buffer, buffer_u16 );
            var list = scr_list_from_buffer( msg_buffer, buffer_f32, size );
            var terminate = buffer_read( msg_buffer, buffer_f32 );
            
            ds_list_add( log, "received list (target " + string( target ) + ")" );
            
            if ( terminate != k_terminate ) {
                ds_list_add( log, "!!! list could not be unpacked" );
                ds_list_destroy( list );
            } else {
                switch( target ) {
                    case msg_list_test: { for( var i = 0; i &lt; ds_list_size( list ); i++ ) show_message( string( ds_list_find_value( list, i ) ) ); break; }
                    case msg_list_terrain_height : { ds_list_destroy( obj_world.lst_terrain_height  ); obj_world.lst_terrain_height  = list; break; }
                    case msg_list_terrain_wetness: { ds_list_destroy( obj_world.lst_terrain_wetness ); obj_world.lst_terrain_wetness = list; break; }
                    case msg_list_terrain_tempr  : { ds_list_destroy( obj_world.lst_terrain_tempr   ); obj_world.lst_terrain_tempr   = list; break; }
                    case msg_list_terrain_tree   : { ds_list_destroy( obj_world.lst_terrain_tree    ); obj_world.lst_terrain_tree    = list; break; }
                    case msg_list_terrain_feature: { ds_list_destroy( obj_world.lst_terrain_feature ); obj_world.lst_terrain_feature = list; break; }
                    case msg_list_terrain_colour : { ds_list_destroy( obj_world.lst_terrain_colour  ); obj_world.lst_terrain_colour  = list; break; }
                    case msg_list_terrain_seed   : { ds_list_destroy( obj_world.lst_terrain_seed    ); obj_world.lst_terrain_seed    = list; break; }
                    case msg_list_terrain_light  : { ds_list_destroy( obj_world.lst_terrain_light   ); obj_world.lst_terrain_light   = list; break; }
                    case msg_list_terrain_rim    : { ds_list_destroy( obj_world.lst_terrain_rim     ); obj_world.lst_terrain_rim     = list; break; }
                    default: {
                        ds_list_destroy( list );
                        ds_list_add( log, "!!! unknown target for list (" + string( target ) + ")" );
                        break;
                    }
                }                
            }
            
            scr_remove_all_timed_ticket( id, tkt_ping_timeout );
            break;
        }
        
        case server_regenerate_msg: { //Regenerate from server
            
            ds_list_add( log, "server requests regen" );
            
            scr_regenerate_models();
            
            scr_remove_all_timed_ticket( id, tkt_ping_timeout );
            break;
        }
        
        case server_start_msg: { //Start from server
            
            ds_list_add( log, "server started the game" );
            ds_list_add( chat, "The host has started the game." );
            
            scr_window_close( wnd_client );
            scr_game_start();
            
            scr_client_started();
            
            scr_remove_all_timed_ticket( id, tkt_ping_timeout );
            break;
        }
        
        default: { //error / corruption catching
        
            ds_list_add( log, "??? unknown data packet on " + string( msg_socket ) + " ???" );
            
            scr_remove_all_timed_ticket( id, tkt_ping_timeout );
            break;
        }
    }  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
