<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*

Planet Model tech demo
Julian Adams 2015

juju8746@gmail.com
/u/jujuadam
GMC: Juju

Significant contributions by GMC users:
Yourself
Boris
xot
xygthop3



SCHEME:

The number of consectutive subdivisions to perform - an integer and don't go below 2 or above 7!
globalvar number_of_subdivisions;
          number_of_subdivisions = 6;

We start with the base dodecahedron configuration of 20 triangles and each subdivision step creates 3 new triangles
globalvar number_of_triangles;
          number_of_triangles = 20 * power( 3, k_subdivisions );

This is a simplified version of:
Tiles = 12 + ( Triangles - 60 ) / 6
globalvar number_of_tiles;
          number_of_tiles = 2 + ( k_triangles / 6 );

It turns out that running at 6 subdivisions produces a world that's 90 tiles around the equator and 46 from pole-to-pole.
This is comparable to Civ 5's 80x52 "standard" map though the number of tiles (2432) actually falls below the "small" map size.
7 subdivisions creates a world that's 82 tiles pole-to-pole and 135 around the waist - that's about the same size as a Civ 5 "huge" map.
Unfortunately, because spherical tiling isn't the same as cylindrical, this result in 7292 tiles versus Civ 5's 10240.
Still, that's larger than Civ 5's "large" map. The problem is that 7 subdivisions is pretty slow...

Relief values, the relative size of terrain features, need to be higher for lower numbers of tiles




Constant that changes model scales


The planet model is separated out into chunks. Each chunk contains a certain amount of hexes
This is a trade off between speed of drawing and speed of regeneration
For example, if a player cuts down some trees, we don't want to regenerate the whole planet again!
However, drawing lots of models slows things down. Since we're untextured, we can get away with more models than we could otherwise.



IMPORTANT CONSTANTS:

k_triangles = 20 * power( 3, k_subdivisions )
k_hexes = ( k_triangles / 6 ) + 2
k_chunks = ceil( k_chunks / k_chunk_size )

k_subdivisions = 4
k_triangles = 1620
k_hexes = 272
k_world_relief = 0.38
k_model_scale = 2.8
k_tree_scale = 3.33
k_skin_size = 32 (minimum)

k_subdivisions = 5
k_triangles = 4860
k_hexes = 812
k_world_relief = 0.2
k_model_scale = 1.8
k_tree_scale = 1.33
k_skin_size = 32 (minimum)

k_subdivisions = 6
k_triangles = 14580
k_hexes = 2432
k_world_relief = 0.16
k_model_scale = 1.2
k_tree_scale = 1
k_skin_size = 64 (minimum)

k_subdivisions = 7
k_triangles = 43740
k_hexes = 7292
k_world_relief = 0.08
k_model_scale = 1
k_tree_scale = 0.556
k_skin_size = 128 (minimum)




KEY OBJECTS:

obj_init
Creates all other instances, creates the two globally scoped ds_lists that act as the chat and log system.
This object also defines a huge amount of globally scoped variables that control world generation etc.

obj_camera
Performs most of the 3D world drawing, handles the camera and a fair chunk of the world-interaction UX.

obj_world
Generates the world using a sequential processing method. Has a few injection points to allow for regeneration of different kinds.

obj_window_layer
Handles the window system, both drawing and interaction. The window system uses a strange manual event triggering method to get greater control over the execution order.
Also acts as a parent/mounting point for GUI buttons.

obj_gui_layer
Draws a variety of UI elements.




PREFIXES:

scr_, obj_, spr_, bck_, fnt_, shd_, rm_
Straight-forward abbreviations for GameMaker resources.

c_
A colour constant. Chosen to mesh nicer with GM's standard constant definitions

k_
A constant, usually something abstract. Have a peek in the macros section.

wnd_, btn_
A window and a button. Windows are handled by obj_window_layer.

tex_, skn_
A texture. Skins are also textures but are used with the shd_texture_blend special shader.

tkt_, msg_
Constants implemented to smooth readability and consistency of netcode.



Congratulations on reaching the bottom. If you do need to ask any questions, feel free to email me: juju8746@gmail.com
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
