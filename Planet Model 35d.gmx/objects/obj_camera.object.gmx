<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>5</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Camera properties

//I got here through a bit of experimentation. I kinda like the fish-eyed-ness
camera_view_ang = 10; //10 to 20

camera_pos = 1;

//Nifty bit of lerping to allow for varied view angles. IMO looks best at 10 degrees
camera_y_near = lerp(  -200,  -110, ( camera_view_ang/10 ) - 1 );
camera_z_near = lerp(  -320,  -200, ( camera_view_ang/10 ) - 1 );
camera_y_far  = lerp(     0,     0, ( camera_view_ang/10 ) - 1 );
camera_z_far  = lerp( -2800, -2000, ( camera_view_ang/10 ) - 1 );

//
camera_rotation_speed_far  = lerp( 0.010, 0.009, ( camera_view_ang/10 ) - 1 );
camera_rotation_speed_near = lerp( 0.004, 0.005, ( camera_view_ang/10 ) - 1 );
camera_rotation_speed = lerp( camera_rotation_speed_near, camera_rotation_speed_far, camera_pos );
camera_rotation_mouse_coeff = 0.2;

//Precompute camera position
camera_zoom_speed = 0.015;
camera_rotation_mouse_wheel_coeff = 4; //The mouse wheel moves quite slowly so it needs a multiplier to make it feel "engaged"

camera_x = 0;
camera_y = lerp( camera_y_near, camera_y_far, camera_pos );
camera_z = lerp( camera_z_near, camera_z_far, camera_pos );

camera_mouse_grab = false;
camera_mouse_grab_x = 0;
camera_mouse_grab_y = 0;

camera_layer_view = k_physical;
camera_prev_layer_view = noone;
camera_layer_transition = 0.0001;

sur_camera_model = surface_create( view_wview[0], view_hview[0] );
sur_camera_sun   = surface_create( view_wview[0], view_hview[0] );

sur_camera_skin = surface_create( k_skin_size, k_skin_size );
skn_camera_skin = surface_get_texture( sur_camera_skin );

surface_set_target( sur_camera_skin );
draw_clear_alpha( c_black, 0 );
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mouse / misc properties

//Variables (modified in the step event) that represent the camera -&gt; mouse vector
mouse_vx = 0;
mouse_vy = 0;
mouse_vz = 1;

//Where the mouse pointer is touching the sphere
mouse_touch_x = 0;
mouse_touch_y = 0;
mouse_touch_z = 0;

//Coordinate tracking
mouse_down_x = 0;
mouse_down_y = 0;

//Hex interaction
mouse_hex_over_id = noone;
mouse_hex_down_id = noone;
mouse_hex_release_id = noone;

//Instance interaction
mouse_inst_over_id = noone;
mouse_inst_down_id = noone;
mouse_inst_release_id = noone;

//Loading screen / globe reveal code. Pretty horrid but makes the right kind of moves
reveal_fade = 1;
reveal = false;
auto_reveal = false;
first_run = true;

//Instance selection variables
inst_selected = noone;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///3D initialisation

//Better do that whole "three-dee" thing
d3d_start();

//Culling no longer screws up trees!
d3d_set_culling( true );

//No lighting please
d3d_set_lighting( false );

//We don't want to let the depth system mess with the draw order
d3d_set_depth( false );

//Set up the quaternion that represents the rotation of the world model
camera_quaternion = ds_quaternion_create();

//Precompute a d3d transformation for the quaternion
ds_quaternion_get_rotation_axis( camera_quaternion );
camera_quat_a = result_coord[0];
camera_quat_b = result_coord[1];
camera_quat_c = result_coord[2];
camera_quat_d = result_coord[3];

ds_list_add( log, "Camera started" );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_quaternion_destroy( camera_quaternion );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Globe reveal

if ( auto_reveal ) and ( obj_world.generation_finished ) {
    reveal = true;
}

if ( reveal ) {
    reveal_fade = 0;
    if ( reveal_fade == 0 ) and ( first_run ) first_run = false;
    reveal_fade = max( 0, reveal_fade - 0.01 );
    
} else {
    reveal_fade = 1;
    reveal_fade = min( 1, reveal_fade + 0.05 );
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Keyboard controls

var permit_keyboard_control;

permit_keyboard_control = true;

if ( !reveal ) permit_keyboard_control = false;
if ( !camera_keyboard_movement ) permit_keyboard_control = false;
if ( instance_exists( wnd_chat ) ) {
    if ( obj_window_layer.window_global_mouse_over == wnd_chat.id ) permit_keyboard_control = false;
}

//Only do stuff if the world is actually visible
if ( permit_keyboard_control ) {
    
    //Quaternion rotation is kinda bananas so I don't fully understand what's going on here
    if ( keyboard_check( ord( "W" ) ) ) ds_quaternion_multiply_left( camera_quaternion,   1, -camera_rotation_speed * d_time_mod, 0, 0 );
    if ( keyboard_check( ord( "S" ) ) ) ds_quaternion_multiply_left( camera_quaternion,   1,  camera_rotation_speed * d_time_mod, 0, 0 );
    if ( keyboard_check( ord( "A" ) ) ) ds_quaternion_multiply_left( camera_quaternion,   1, 0, -camera_rotation_speed * d_time_mod, 0 );
    if ( keyboard_check( ord( "D" ) ) ) ds_quaternion_multiply_left( camera_quaternion,   1, 0,  camera_rotation_speed * d_time_mod, 0 );
    if ( keyboard_check( ord( "E" ) ) ) ds_quaternion_multiply_left( camera_quaternion,   1, 0, 0, -camera_rotation_speed_far * d_time_mod );
    if ( keyboard_check( ord( "Q" ) ) ) ds_quaternion_multiply_left( camera_quaternion,   1, 0, 0,  camera_rotation_speed_far * d_time_mod );
    
    //Reset the rotation... useful if you get lost
    if ( keyboard_check( ord( "R" ) ) ) ds_quaternion_reset( camera_quaternion );
        
    //"Zoom" code. Actually just lerps the camera along a path rather than doing any FoV stuff
    if ( keyboard_check( vk_up   ) ) camera_pos = max( 0, camera_pos - camera_zoom_speed * d_time_mod );
    if ( keyboard_check( vk_down ) ) camera_pos = min( 1, camera_pos + camera_zoom_speed * d_time_mod );

}

    
if ( obj_window_layer.window_global_mouse_over == noone ) {
    if ( mouse_wheel_up() )   camera_pos = max( 0, camera_pos - camera_zoom_speed * camera_rotation_mouse_wheel_coeff * d_time_mod );
    if ( mouse_wheel_down() ) camera_pos = min( 1, camera_pos + camera_zoom_speed * camera_rotation_mouse_wheel_coeff * d_time_mod );
}
    
//Figure out where the camera is. Back in the day, we used merge_color() to interpolate!
camera_x = 0;
camera_y = lerp( camera_y_near, camera_y_far, camera_pos );
camera_z = lerp( camera_z_near, camera_z_far, camera_pos );
camera_rotation_speed = lerp( camera_rotation_speed_near, camera_rotation_speed_far, camera_pos );

//Precompute a d3d transformation for the quaternion
ds_quaternion_get_rotation_axis( camera_quaternion );
camera_quat_a = result_coord[0];
camera_quat_b = result_coord[1];
camera_quat_c = result_coord[2];
camera_quat_d = result_coord[3];
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mouse over hex code

var touch_x, touch_y, touch_z, i, result;
var xx, yy, zz, height, costheta, largest, touching;

//If the game isn't minimized or in the process of changing resolution
if ( window_get_width() != 0 ) and ( window_get_height() != 0 ) {

    //This function returns the vector that connects the centre of the camera and the mouse pointer
    //With thanks to "Yourself" off the GMC.
    scr_projection_2d_to_3d( camera_x, camera_y, camera_z,    0,0,-k_world_scale,   0,1,0,   obj_camera.camera_view_ang, view_wview[0], view_hview[0],   mouse_x, mouse_y );
    mouse_vx = result_coord[0];
    mouse_vy = result_coord[1];
    mouse_vz = result_coord[2];
    
} else {

    mouse_vx = 0;
    mouse_vy = 0;
    mouse_vz = -1;
    
}

//Assume we're not even touching the sphere
touching = false;

//If the mouse is over a window or the world hasn't finished generating, the mouse cannot touch a hex
if ( ( instance_exists( obj_window_layer ) ) and ( obj_window_layer.window_global_mouse_over ) ) or ( !obj_world.generation_finished ) {
    
    mouse_hex_over_id = noone;
    
} else {
    
    //Run through the possible height values and get an intersection point for each potential height
    for( i = 0; i &lt; 6; i++ ) {
        
        result = scr_get_line_sphere_intersection( camera_x, camera_y, camera_z,    mouse_vx, mouse_vy, mouse_vz,   ds_list_find_value( world_relief_list, i ) * k_world_scale );
                                                
        //get_line_sphere_intersection returns "false" if there's no intersection
        //If at least one height value returns a value then we know we've touched the sphere                  
        if ( result != 0 ) touching = true;
        
        //get_line_sphere_intersection also returns coordinates in an array. We want to store those in our own temporary array
        touch_x[i] = result_coord[0];
        touch_y[i] = result_coord[1];
        touch_z[i] = result_coord[2];
    }
    
    //If the mouse is actually touching the sphere at one of the relief values
    if ( touching ) {
        
        //Rotate the touch vectors in the object's frame of reference i.e. with quaternion rotation
        for( i = 0; i &lt; 6; i++ ) {
            ds_quaternion_rotate_vector( camera_quaternion,   touch_x[i], touch_y[i], touch_z[i] );
            touch_x[i] = result_coord[0];
            touch_y[i] = result_coord[1];
            touch_z[i] = result_coord[2];
        }
        
        //Run through all the hexes and find which one is closest
        //I hate this method but I can't think of a better one for now
        //
        //This method uses the dot product relationship: A . B = |A| |B| cos( theta ), or as we're using it, cos( theta ) = ( A . B ) / ( |A| |B| )
        //"theta" is the angle between the two vectors. We're looking for the smallest angle between the mouse vector and the position vector of each hex
        //The small angle approximation for cos() is: cos( theta ) = 1 - sqr( theta ) / 2, or, theta = sqrt( 1 - cos( theta ) )
        //We're looking for the largest value of [cos( theta )] as that corresponds to the smallest value of "theta" itself. This means we don't need to mess around with trig! Hooray!
        //
        //Also, the touch_x[] etc arrays we created above are used here to maintain accuracy because not all hexagons sit at the same distance from the origin
        
        largest = noone;
        mouse_hex_over_id = noone;
        
        var x_list = obj_world.lst_hex_x;
        var y_list = obj_world.lst_hex_y;
        var z_list = obj_world.lst_hex_z;
        var h_list = obj_world.lst_terrain_height;
        
        for( i = 0; i &lt; k_hexes; i++ ) {
            
            xx = ds_list_find_value( x_list, i );
            yy = ds_list_find_value( y_list, i );
            zz = ds_list_find_value( z_list, i );
            height = ds_list_find_value( h_list, i ) * 5;
            
            costheta = dot_product_3d_normalised( xx, yy, zz,   touch_x[height], touch_y[height], touch_z[height] );
            
            if ( costheta &gt; largest ) {
                largest = costheta;
                mouse_hex_over_id = i;
            }
        }
        
        //Drop the arrays to try to save some memory
        touch_x = noone;
        touch_y = noone;
        touch_z = noone;
        
    } else {
        //If the mouse isn't touching the sphere, there's no valid hex ID
        mouse_hex_over_id = noone;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Unit/Hex clicking
var unit, path_inst, i, flag_inst, hex;

//Record where on the screen the player clicked the mouse
if ( mouse_check_button_pressed( mb_left ) ) {
    mouse_down_x = mouse_x;
    mouse_down_y = mouse_y;
}


//Assign variables for what hex the player has pressed / released
if ( mouse_hex_over_id != noone ) and ( obj_window_layer.window_global_mouse_over == noone ) {
    if ( mouse_check_button_pressed( mb_left ) ) mouse_hex_down_id = mouse_hex_over_id;
    if ( mouse_check_button_released( mb_left ) ) mouse_hex_release_id = mouse_hex_over_id;
}


mouse_inst_over_id = noone;

//Assign variables for what army the player has pressed / released
if ( mouse_hex_over_id != noone ) and ( obj_window_layer.window_global_mouse_over == noone ) and ( camera_layer_view == k_military ) {
    mouse_inst_over_id = scr_find_unit_on_hex( mouse_hex_over_id );
    if ( mouse_check_button_pressed( mb_left ) ) mouse_inst_down_id = mouse_inst_over_id;
    if ( mouse_check_button_released( mb_left ) ) mouse_inst_release_id = mouse_inst_over_id;
}


if ( mouse_check_button( mb_left ) ) {

    //Clear any existing path for this army if the player starts to make a new path
    if ( mouse_hex_over_id != noone ) and ( mouse_inst_down_id != noone ) and ( mouse_inst_over_id != mouse_inst_down_id ) and( mouse_inst_down_id.path != noone ) {
        with( mouse_inst_down_id.path ) instance_destroy();
    }
    
}

if ( mouse_check_button_released( mb_left ) ) {
    
    //If the player is touching any hex
    if ( mouse_hex_over_id != noone ) {
        
        //If the player has pressed an army
        if ( mouse_inst_down_id != noone ) {
            
            //If the player has released on a tile that has no army on it
            if ( mouse_inst_release_id == noone ) {
                
                path_inst = scr_create_simple_path( mouse_hex_down_id, mouse_hex_release_id ); //Create a dumb as-the-crow-flies path
                path_inst.army = mouse_inst_down_id; //Assign the army to the path
                mouse_inst_down_id.path = path_inst; //Assign the path to the army
                
                //For all hexes on the path
                for( i = 0; i &lt; ds_list_size( path_inst.path_list ); i++ ) {
                    
                    flag_inst = instance_create( 0, 0, obj_path_post ); //Add a new post
                    ds_list_add( path_inst.inst_list, flag_inst ); //Add the post's instance id to the path's list
                    
                    flag_inst.path = path_inst; //Assign the path's instance id to the flag
                    
                    flag_inst.hex_location = ds_list_find_value( path_inst.path_list, i ); //Assign the hex
                    flag_inst.index = i; //And tell the post what index it is on the path's list (not sure this is used anywhere but it's useful information)
                    
                }
                
            //If the player releases on the same army they pressed then select that army
            } else if ( mouse_inst_down_id == mouse_inst_release_id ) {
                inst_selected = mouse_inst_down_id
            }
        
        } else {
            
            //Delect an army if the player has clicked on an empty spot on the globe and HASN'T tried to drag to rotate the globe
            if ( abs( mouse_down_x - mouse_x ) + abs( mouse_down_y - mouse_y ) &lt; mouse_dead_zone ) {
                inst_selected = noone;
                mouse_inst_down_id = noone;
            }
        }
    
    //Deselect an instance if the player clicks off the globe and not on a window
    } else if ( obj_window_layer.window_global_mouse_over == noone ) and ( mouse_hex_down_id == noone ) inst_selected = noone;
    
    //Regardless, if the player releases the left mouse button, de-press a hex and de-press an army unit
    mouse_hex_down_id = noone;
}



//Deselect everyone if the game is calculating the next turn
if ( instance_exists( par_game ) ) if ( par_game.next_turn ) {
    mouse_inst_down_id = noone;
    mouse_inst_release_id = noone;
    inst_selected = noone;
}


//Sort out the army information dialogue
if (  instance_exists( wnd_army_details ) ) and ( inst_selected == noone ) scr_window_close( wnd_army_details );
if ( !instance_exists( wnd_army_details ) ) and ( inst_selected != noone ) scr_window_create( wnd_army_details, obj_window_layer, noone, noone, noone, noone );
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drag conrols
var xx, yy, button_over;


if ( !obj_world.generation_finished ) window_set_cursor( cr_appstart ) else {
    if ( camera_mouse_grab ) window_set_cursor( cr_size_all ) else window_set_cursor( cr_default );
    with( par_global_button ) if ( mouse_over ) window_set_cursor( cr_handpoint );
}

if ( mouse_hex_over_id != noone ) and ( reveal ) and ( mouse_inst_over_id != noone ) window_set_cursor( cr_handpoint );



if ( mouse_check_button_pressed( mb_left ) ) and ( mouse_hex_over_id != noone ) and ( mouse_inst_down_id == noone ) and ( obj_window_layer.window_global_mouse_over == noone ) {
    camera_mouse_grab = true;
}

if ( mouse_check_button_released( mb_left ) ) camera_mouse_grab = false;

if ( camera_mouse_grab ) {
    
    xx = camera_mouse_grab_x - mouse_x;
    yy = camera_mouse_grab_y - mouse_y;
    xx *= camera_rotation_speed * camera_rotation_mouse_coeff;
    yy *= camera_rotation_speed * camera_rotation_mouse_coeff;
    
    ds_quaternion_multiply_left( camera_quaternion,   1, 0, xx, 0 );
    ds_quaternion_multiply_left( camera_quaternion,   1, yy, 0, 0 );

}

camera_mouse_grab_x = mouse_x;
camera_mouse_grab_y = mouse_y;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Surface management

if ( surface_get_width( sur_camera_sun ) != view_wview[0] ) or ( surface_get_width( sur_camera_sun ) != view_wview[0] ) or ( !surface_exists( sur_camera_sun ) ) {
    surface_free( sur_camera_sun );
    sur_camera_sun = surface_create( view_wview[0], view_hview[0] );
}

if ( surface_get_width( sur_camera_model ) != view_wview[0] ) or ( surface_get_width( sur_camera_model ) != view_wview[0] ) or ( !surface_exists( sur_camera_model ) ) {
    surface_free( sur_camera_model );
    sur_camera_model = surface_create( view_wview[0], view_hview[0] );
}

with( obj_world ) if ( generation_finished ) scr_skin_check();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Skin transition

var sur_a, sur_b;

if ( obj_world.generation_finished ) and ( reveal ) {
    
    switch( camera_prev_layer_view ) {
        case k_tech: {
            sur_a = obj_world.sur_tech;
            break;
        }
        case k_economy: {
            sur_a = obj_world.sur_economy;
            break;
        }
        case k_influence: {
            sur_a = obj_world.sur_influence;
            break;
        }
        case k_military: {
            sur_a = obj_world.sur_military;
            break;
        }
        case k_physical: {
            sur_a = obj_world.sur_lighting;
            break;
        }
        default: {
            sur_a = noone;
            break;
        }
    }
    
    scr_draw_to_surface( sur_camera_skin );
    draw_clear_alpha( c_black, 0 );
    draw_set_blend_mode_ext( bm_src_alpha_sat, bm_one ) 
    
    if ( sur_a != noone ) draw_surface_ext( sur_a, 0, 0, 1, 1, 0, c_white, 1 - camera_layer_transition ) else {
        draw_set_color( c_space );
        draw_set_alpha( 1 - camera_layer_transition );
        draw_rectangle( 0, 0, k_skin_size - 1, k_skin_size - 1, false );
        draw_set_alpha( 1 );
        draw_set_color( c_white );
    }
    
    if ( camera_layer_transition &gt; 0 ) {
        
        camera_layer_transition += 0.03 * d_time_mod;
        camera_layer_transition = min( 1, camera_layer_transition );
        
        switch( camera_layer_view ) {
            case k_tech: {
                sur_b = obj_world.sur_tech;
                break;
            }
            case k_economy: {
                sur_b = obj_world.sur_economy;
                break;
            }
            case k_influence: {
                sur_b = obj_world.sur_influence;
                break;
            }
            case k_military: {
                sur_b = obj_world.sur_military;
                break;
            }
            case k_physical: {
                sur_b = obj_world.sur_lighting;
                break;
            }
            default: {
                sur_b = noone;
                break;
            }
        }
        
        if ( sur_b != noone ) draw_surface_ext( sur_b, 0, 0, 1, 1, 0, c_white, camera_layer_transition ) else {
            draw_set_color( c_space );
            draw_set_alpha( camera_layer_transition );
            draw_rectangle( 0, 0, k_skin_size - 1, k_skin_size - 1, false );
            draw_set_alpha( 1 );
            draw_set_color( c_white );
        }
        
        if ( camera_layer_transition == 1 ) {
            camera_layer_transition = 0;
            camera_prev_layer_view = camera_layer_view;
        }
        
    }
    
    draw_set_blend_mode( bm_normal );
    surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Do pretty things

var i, sun_vector, do_sun, border, sun_x, sun_y, sur_a, sur_b;

do_sun = false;

//If the generator has finished doing its thing
if ( obj_world.generation_finished ) {
    
    if ( fancy_sun ) {
        
        //Set up a transform that puts the sun where we want it
        d3d_transform_set_identity();
        d3d_transform_set_translation( -k_sun_distance, 0, 0 );
        d3d_transform_add_rotation_y( radtodeg( -obj_world.terrain_light_offset ) );
        d3d_transform_add_rotation_axis( camera_quat_a, camera_quat_b, camera_quat_c, camera_quat_d );
        sun_vector = d3d_transform_vertex( 0, 0, 0 );
        d3d_transform_set_identity();
        
        //Set our draw target to the model surface
        surface_set_target( sur_camera_model );
        
        //Sweep the view with our background colour
        draw_clear_alpha( c_space, 0 );
        
    }
    
    //Make sure we're in the correct 3D projection
    scr_projection_camera();
    
    //Draw armies
    with( par_game_draw ) event_user( 0 );
    
    //Add a transformation to put the planet model in the right orientation
    d3d_transform_set_identity();
    d3d_transform_add_rotation_axis( camera_quat_a, camera_quat_b, camera_quat_c, camera_quat_d );
    
    //Draw the starfield
    if ( fancy_stars ) d3d_model_draw( obj_world.model_starfield, 0, 0, 0, -1 );
    
    //Interpolation messes with the shader we use
    texture_set_interpolation( false );
    shader_set( shd_texture_blend );
    
    //Draw the physical terrain (mountains etc) and the trees/buildings using the skin
    scr_model_group_draw_texture( obj_world.lst_model_physical, skn_camera_skin );
    scr_model_group_draw_texture( obj_world.lst_model_features, skn_camera_skin );
    
    //Reset some things
    shader_reset();
    texture_set_interpolation( true );
    
    //Draw the orange planetary core
    var core_scale = k_world_scale * 0.2;
    draw_set_color( c_orange );
    d3d_draw_ellipsoid( -core_scale, -core_scale, -core_scale,   core_scale, core_scale, core_scale,   -1, 1, 1, 6 );
    draw_set_blend_mode( bm_normal );
    
    d3d_transform_set_identity();
    if ( fancy_sun ) surface_reset_target();  
    
    //If we're on the physical view and we're drawing the sun
    if ( camera_layer_view == k_physical ) and ( fancy_sun ) {
        
        scr_projection_3d_to_2d( camera_x, camera_y, camera_z,   0,0,-k_world_scale,   0,1,0,   camera_view_ang, view_wview[0], view_hview[0],   sun_vector[0], sun_vector[1], sun_vector[2] );
        sun_x = result_coord[0];
        sun_y = result_coord[1];
        
        //Give us a bit of a border before we fully exclude the sun
        border = k_sun_scale * 1.333333;
        
        //The sun is outside the view
        if ( sun_x &gt;= -border ) and ( sun_x &lt;= view_wview[0] + border ) and ( sun_y &gt;= -border ) and ( sun_y &lt;= view_hview[0] + border ) do_sun = true;
        
        //And if the sun is in front of the camera rather than behind it
        if ( dot_product_3d( camera_x, camera_y, camera_z,   sun_vector[0], sun_vector[1], sun_vector[2] ) &gt; 0 ) do_sun = false;
        
        if ( do_sun ) {
            
            //Set our draw target to a special surface set up for the sun
            surface_set_target( sur_camera_sun );
            scr_projection_camera();
            
            //Sweep the view with our background colour
            draw_clear_alpha( c_space, 0 );
            
            d3d_transform_set_identity();
            d3d_transform_set_translation( -k_sun_distance, 0, 0 );
            d3d_transform_add_rotation_y( radtodeg( -obj_world.terrain_light_offset ) );
            d3d_transform_add_rotation_axis( camera_quat_a, camera_quat_b, camera_quat_c, camera_quat_d );
            
            draw_set_color( c_sun );
            d3d_draw_ellipsoid( -k_sun_scale, -k_sun_scale, -k_sun_scale,    k_sun_scale, k_sun_scale, k_sun_scale,    -1, 1, 1, 50 );
            draw_set_color( c_white );
            
            d3d_transform_set_identity();
            
            scr_projection_ortho( sur_camera_sun );
            
            //We want to subtract from the sun's luminence - this is called occlusion
            draw_set_blend_mode( bm_subtract );
            
            //Draw the terrain and the features in black
            draw_surface_ext( sur_camera_model, 0, 0,   1, 1, 0, c_black, 1 );
            
            //Reset things
            draw_set_blend_mode( bm_normal );
            surface_reset_target();
            
        }
    }
}

//Set the view to the familiar 2D perspective
scr_projection_ortho( noone );

if ( fancy_sun ) {
    
    //Draw the model surface to the screen
    draw_surface( sur_camera_model, 0, 0 );
    
    //Draw crepuscular rays
    if ( do_sun ) {
        
        //Set up the GPU to draw things as we want them
        draw_set_blend_mode( bm_add );
        shader_set( shd_god_rays );
        
        //Tell the shader where to disperse the rays from
        shader_set_uniform_f( shader_get_uniform( shd_god_rays, "lightPositionOnScreen" ),
                              clamp( sun_x, 0, view_wview[0] ) / view_wview[0],
                              clamp( sun_y, 0, view_wview[0] ) / view_hview[0] );
        
        //Draw the sun surface
        draw_surface( sur_camera_sun, 0, 0 );
        
        //And relax
        draw_set_blend_mode( bm_normal );
        shader_reset();
    
    }
}

//Draw the blank-out for fading between loading and display screens
if ( reveal_fade &gt; 0 ) {
    
    draw_set_alpha( reveal_fade );
    draw_set_color( background_color );
    draw_rectangle( 0, 0, view_wview[0], view_hview[0], false );
    draw_set_alpha( 1 );
    draw_set_color( c_white );
    
}



//----- Here be debug

draw_set_color( c_white );
draw_set_halign( fa_left );
//if ( reveal ) and ( mouse_hex_over_id != noone ) draw_text( 60, 5, string( mouse_hex_over_id ) + ", " + string( mouse_inst_over_id ) + " = " + string( ds_list_find_value( obj_world.lst_terrain_rim, mouse_hex_over_id ) ) );
//if ( reveal ) draw_text( 60, 25, string( obj_world.chunk_per_step * k_chunk_size ) );

/*
if ( obj_world.generation_finished ) {
    texture_set_interpolation( false );
    
    draw_set_color( c_black );
    draw_rectangle( 59, 49, 60 + k_skin_size * 6, 50 + k_skin_size * 6, false );
    draw_set_color( c_white );
    
    draw_surface_ext( sur_camera_skin, 60, 50, 6, 6, 0, c_white, 1 );
    
    texture_set_interpolation( true );
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
