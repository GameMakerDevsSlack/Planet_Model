<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Default Create

//All drawing is manually handled by obj_window_layer
visible = false;

//If clicking on the window brings the window to the front
window_can_bring_forward = true;

//Fixes some weirdness with user events
window_self_destroy = false;
window_button_pressed = false;

//These are initialised here but set elsewhere
window_width = 0;
window_height = 0;
window_local_x = 0;
window_local_y = 0;
window_screen_x = 0;
window_screen_y = 0;

//All windows have a surface that they own and draw on to
window_surface = noone;

//The children system allows nested windows!
window_children = ds_list_create();
parent = id;

//Set the behaviour of buttons
window_buttons = ds_list_create();
window_closeable = true;
window_acceptable = false;
window_moveable = true;

//And in-built scrollbars
window_scroll_x = false;
window_scroll_y = false;
window_scroll_x_offset = 0;
window_scroll_y_offset = 0;
window_scroll_x_limit = 0;
window_scroll_y_limit = 0;
window_scroll_x_scale = 0;
window_scroll_y_scale = 0;

//Move bar
window_moving = false;
window_mouse_down_x = 0;
window_mouse_down_y = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Default Destroy

var i;

//Delete the entry in the parent's list
ds_list_delete( parent.window_children, ds_list_find_index( parent.window_children, id ) );

//Go through each child and button and destroy them. We do this in reverse to avoid the lists going out of bounds
for( i = ds_list_size( window_children ) - 1; i &gt;= 0 ; i-- ) with( ds_list_find_value( window_children, i ) ) instance_destroy();
for( i = ds_list_size( window_buttons  ) - 1; i &gt;= 0 ; i-- ) with( ds_list_find_value( window_buttons , i ) ) instance_destroy();

//Destroy some lists
ds_list_destroy( window_children );
ds_list_destroy( window_buttons );

//Free the VRAM taken up by the surface
surface_free( window_surface );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ( !surface_exists( window_surface ) ) window_surface = surface_create( window_width, window_height );

window_scroll_x = clamp( window_scroll_x, 0, window_scroll_x_limit );
window_scroll_y = clamp( window_scroll_y, 0, window_scroll_y_limit );;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Default Draw

scr_window_post_draw();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Default Step

//Handle button press
window_button_pressed = false;

//Execute the step behaviours of the child windows before this window
//We go backwards to process mouse over conditionals for the (graphical) top window
for( i = ds_list_size( window_children ) - 1; i &gt;= 0; i-- ) {
    inst = ds_list_find_value( window_children, i );
    with( inst ) event_user( 1 );
}

//Simple mouse-over check
if ( obj_window_layer.window_global_mouse_over == noone ) and ( point_in_rectangle( mouse_x, mouse_y,   window_screen_x, window_screen_y,   window_screen_x + window_width, window_screen_y + window_height ) ) {
    
    obj_window_layer.window_global_mouse_over = id;
    
    //Bump this window to the top of its parent's draw order if clicked
    if ( mouse_check_button_pressed( mb_left ) ) and ( window_can_bring_forward ) ds_list_bump_end( parent.window_children, ds_list_find_index( parent.window_children, id ) );
    
}

//Handle button presses
for( i = 0; i &lt; ds_list_size( window_buttons ); i++ ) {
    inst = ds_list_find_value( window_buttons, i );
    with( inst ) event_user( 1 );
}
    
if ( obj_window_layer.window_global_mouse_over == id ) and ( window_moveable ) and ( !window_button_pressed ) and ( mouse_check_button_pressed( mb_left ) ) {
    
    //If this window is moveable, record the mouse's coordinates and tell the window to follow the mouse
    window_moving = true;
    window_mouse_down_x = mouse_x - window_screen_x;
    window_mouse_down_y = mouse_y - window_screen_y;
    
}

//If this window is moveable and is being moved
if ( !mouse_check_button( mb_left ) ) window_moving = false;
if ( window_moving ) scr_window_move( id, mouse_x - window_mouse_down_x, mouse_y - window_mouse_down_y );

//Update where all the child windows/buttons should be
scr_window_update_position( id );

//Deletion handling (was causing data strucutre bugs if done in a more direct manner)
if ( window_self_destroy ) instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Default Initialisation

window_surface = surface_create( window_width, window_height );

if ( window_closeable ) {
    if ( window_acceptable ) scr_window_add_button( btn_accept, id, window_width - 32, 0 ) else scr_window_add_button( btn_close, id, window_width - 32, 0 );
}

if ( window_scroll_y  ) scr_window_add_button( obj_y_scroll, id, noone, noone );
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
